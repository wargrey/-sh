#lang scribble/lp2

@(require digimon/tamer)

@(define-bib SSH-ARCH
   #:title  "The Secure Shell Protocol Architecture"
   #:author (org-author-name "RFC4251")
   #:date   2006
   #:url    "https://tools.ietf.org/html/rfc4251")

@(define-bib OpenSSL
   #:title  "OpenSSL: Cryptography and SSL/TLS Toolkit"
   #:author (org-author-name "OpenSSL Software Foundation")
   #:date   2019
   #:url    "https://www.openssl.org")

@(define-bib HMAC-SHA
   #:title  "Identifiers and Test Vectors for HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512"
   #:author (org-author-name "RFC4231")
   #:date   2005
   #:url    "https://tools.ietf.org/html/rfc4231")

@(define-bib AES
   #:title  "Advanced Encryption Standard (AES) (FIPS PUB 197)"
   #:author (org-author-name "National Institute of Standards and Technology")
   #:date   2001
   #:url    "https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf")

@handbook-story{The Secure Shell Protocol Architecture}

This section demonstrates the implementation of @~cite[SSH-ARCH].

@;tamer-smart-summary[]

@handbook-scenario{Data Type Representation}

@tamer-action[
 (mpint '0x0)
 (mpint '0x9a378f9b2e332a7)
 (mpint '0x80)
 (mpint '0x-1234)
 (mpint '0x-deadbeef)]

@tamer-action[
 (namelist '())
 (namelist '(zlib))
 (namelist '(zlib none))]

@;handbook-scenario{Psuedo-Random Number Generation}

@handbook-scenario{Host Key Algorithms}

This testcase is generated by @~cite[OpenSSL].

@tamer-racketbox[(digimon-path "tamer" "stone" "openssl_rsa.pem")]

@tamer-action[
 (define pem (rsa-read openssl-rsa.pem))
 (rsa-key-okay? pem)
 (rsa-pretty-display pem 24)
 (define message (file->bytes (digimon-path "tamer" "stone" "openssl_rsa.pub")))
 (define signature (rsa-sign pem message id-sha1))
 (bytes=? signature (file->bytes (digimon-path "tamer" "stone" "openssl_rsa_sha1.sign")))
 (rsa-verify pem message signature id-sha1)]

@handbook-scenario{Confidentiality}

These test cases are defined in @~cite[AES].

@tamer-action[
 (define key-schedule128 (aes-key-schedule aes-key128 4 '0xb6630ca6))
 (define key-schedule192 (aes-key-schedule aes-key192 6 '0x01002202))
 (define key-schedule256 (aes-key-schedule aes-key256 8 '0x706c631e))]

@tamer-action[
 (define state (make-state-array-from-bytes 4 4 (symb0x->octets aes-plaintext)))
 (aes-key-schedule-rotate! key-schedule128)
 (aes-add-round-key state key-schedule128 0)
 (aes-round-step state key-schedule128 1)
 (aes-round-step state key-schedule128 2)
 (aes-round-step state key-schedule128 3)
 (aes-round-step state key-schedule128 4)
 (aes-round-step state key-schedule128 5)
 (aes-round-step state key-schedule128 6)
 (aes-round-step state key-schedule128 7)
 (aes-round-step state key-schedule128 8)
 (aes-round-step state key-schedule128 9)
 (aes-round-done state key-schedule128 10)
 (aes-core-cipher! aes-plaintext aes-key128 aes-ciphertext)]

@tamer-action[
 (aes-core-cipher '0x00112233445566778899aabbccddeeff '0x000102030405060708090a0b0c0d0e0f aes-ciphertext128)
 (aes-core-cipher '0x00112233445566778899aabbccddeeff '0x000102030405060708090a0b0c0d0e0f1011121314151617 aes-ciphertext192)
 (aes-core-cipher '0x00112233445566778899aabbccddeeff '0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f aes-ciphertext256)]

@handbook-scenario{Data Integrity Algorithms}

These test cases are defined in @~cite[HMAC-SHA].

@tamer-action[
 (HMAC testcase1-256 hmac-sha256 (make-bytes 20 #x0B) #"Hi There")
 (HMAC testcase2-256 hmac-sha256 #"Jefe" #"what do ya want for nothing?")
 (HMAC testcase3-256 hmac-sha256 (make-bytes 20 #xAA) (make-bytes 50 #xDD))
 (HMAC testcase4-256 hmac-sha256 (apply bytes (range #x01 #x1A)) (make-bytes 50 #xCD))
 (HMAC testcase5-256 hmac-sha256-128 (make-bytes 20 #x0C) #"Test With Truncation")
 (HMAC testcase6-256 hmac-sha256 (make-bytes 131 #xAA) #"Test Using Larger Than Block-Size Key - Hash Key First")
 (HMAC testcase7-256 hmac-sha256 (make-bytes 131 #xAA) #"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.")]

@handbook-reference[]

@; Chunks after `handbook-reference[]` will never be rendered in documents
@; <*> is the main chunk by convention.

@chunk[|<*>|
       (require digimon/tamer)
       (tamer-taming-start!)

       (module+ tamer |<architecture:*>|)]

@chunk[|<architecture:*>|
       (module+ story
         <datatype>)]

@chunk[<datatype>
       (require (prefix-in pict: pict))
       
       (require "../datatype.rkt")
       (require "../digitama/rsa.rkt")
       (require "../digitama/algorithm/rsa.rkt")
       (require "../digitama/algorithm/hmac.rkt")
       
       (require "../digitama/algorithm/pkcs/hash.rkt")
       (require "../digitama/algorithm/pkcs/emsa-v1_5.rkt")
       (require "../digitama/algorithm/pkcs/primitive.rkt")

       (require "aes.rkt")
       (require "../digitama/algorithm/crypto/s-box.rkt")
       (require "../digitama/algorithm/crypto/pretty.rkt")

       (define openssl-rsa.pem (digimon-path "tamer" "stone" "openssl_rsa.pem"))
       (define sbox-gapsize 8)

       (define aes-key128 '0x2b7e151628aed2a6abf7158809cf4f3c)
       (define aes-key192 '0x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b)
       (define aes-key256 '0x603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4)

       (define aes-plaintext '0x3243f6a8885a308d313198a2e0370734)
       (define aes-ciphertext '0x3925841d02dc09fbdc118597196a0b32)

       (define aes-ciphertext128 '0x69c4e0d86a7b0430d8cdb78070b4c55a)
       (define aes-ciphertext192 '0xdda97ca4864cdfe06eaf70a0ec0d7191)
       (define aes-ciphertext256 '0x8ea2b7ca516745bfeafc49904b496089)
       
       (define testcase1-256 "b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7")
       (define testcase2-256 "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843")
       (define testcase3-256 "773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe")
       (define testcase4-256 "82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b")
       (define testcase5-256 "a3b6167473100ee06e0c796c2955552b")
       (define testcase6-256 "60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54")
       (define testcase7-256 "9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2")
       
       (define octets->integer
         (lambda [os]
           (pkcs#1-octets->integer (apply bytes (map symb0x->number (flatten os))))))

       (define symb0x->octets
         (lambda [i]
           (apply bytes
                  (for/list ([pair (in-list (regexp-match* #px".." (substring (symbol->string i) 2)))])
                    (string->number pair 16)))))
       
       (define mpint
         (lambda [hex]
           (define raw (~a hex))
           (define mphex (string->number (substring raw 2) 16))
           (define bs (ssh-mpint->bytes mphex))
           (define-values (restored _) (ssh-bytes->mpint bs))
           (cons (number->symb0x restored) (bytes->hex-string bs #:separator " "))))

       (define namelist
         (lambda [names]
           (define size (ssh-namelist-length names))
           (define bs (make-bytes size))

           (ssh-namelist->bytes names bs)
           
           (define-values (restored _) (ssh-bytes->namelist bs))
           (cons restored (bytes->hex-string bs #:separator " "))))

       (define state-array-pict
         (let ([/dev/stdout (open-output-string '/dev/stdout)])
           (lambda [state]
             (state-array-pretty-print state #:port /dev/stdout)

             (let ([octets (string-split (bytes->string/latin-1 (get-output-bytes /dev/stdout #true)))])
               (pict:frame (pict:inset (pict:table 4 (map pict:text octets) pict:cc-superimpose pict:cc-superimpose 8 8)
                                       4))))))

       (define rotated-schedule-pict
         (let ([/dev/stdout (open-output-string '/dev/stdout)])
           (lambda [schedule start]
             (define pool (make-bytes 16))

             (integer->integer-bytes (vector-ref schedule (+ start 0)) 4 #false #true pool 00)
             (integer->integer-bytes (vector-ref schedule (+ start 1)) 4 #false #true pool 04)
             (integer->integer-bytes (vector-ref schedule (+ start 2)) 4 #false #true pool 08)
             (integer->integer-bytes (vector-ref schedule (+ start 3)) 4 #false #true pool 12)
             
             (let ([octets (string-split (bytes->hex-string pool #:separator " "))])
               (pict:frame (pict:inset (pict:table 4 (map pict:text octets) pict:cc-superimpose pict:cc-superimpose 8 8)
                                       4))))))
       
       (define aes-key-schedule
         (lambda [0xkey column last-one]
           (define key (symb0x->octets 0xkey))
           
           (printf "Cipher Key = ~a (~a bits)~n" (bytes->hex-string key) (* (bytes-length key) 8))

           (define schedule (aes-key-expand key))
           (define last-word (vector-ref schedule (- (vector-length schedule) 1)))

           (words-pretty-print schedule
                               #:column column
                               #:port (cond [(= last-word (symb0x->number last-one)) (current-output-port)]
                                            [else (current-error-port)]))
           schedule))

       (define aes-add-round-key
         (lambda [state schedule start [space 3]]
           (define Sin (state-array-pict state))

           (state-array-add-round-key! state schedule start)
           
           (pict:hc-append sbox-gapsize
                           (cond [(= space 0) Sin]
                                 [else (apply pict:hc-append sbox-gapsize Sin
                                              (make-list space (pict:ghost Sin)))])
                           (pict:text "âŠ•")
                           (rotated-schedule-pict schedule start)
                           (pict:text "="))))

       (define aes-round-step
         (lambda [state schedule round]
           (define Sin (state-array-pict state))
           
           (state-array-substitute! state aes-substitute-box)
           (define Ssub (state-array-pict state))

           (aes-left-shift-rows! state)
           (define Sshift (state-array-pict state))

           (aes-mixcolumns! state)
           (pict:hc-append sbox-gapsize Sin Ssub Sshift (aes-add-round-key state schedule (* round 4) 0))))

       (define aes-round-done
         (lambda [state schedule round]
           (define Sin (state-array-pict state))
           
           (state-array-substitute! state aes-substitute-box)
           (define Ssub (state-array-pict state))

           (aes-left-shift-rows! state)
           (pict:vl-append sbox-gapsize
                           (pict:hc-append sbox-gapsize Sin Ssub (aes-add-round-key state schedule (* round 4) 1))
                           (state-array-pict state))))

       (define aes-core-cipher
         (lambda [0xplaintext 0xkey 0xciphertext]
           (define plaintext (symb0x->octets 0xplaintext))
           (define ciphertext (symb0x->octets 0xciphertext))
           (define key (symb0x->octets 0xkey))
           (define-values (encrypt decrypt) (aes-cipher key))
           (define ctext (encrypt plaintext))
           (define ptext (decrypt ctext))
           (define encryption-okay? (bytes=? ctext ciphertext))
           (define decryption-okay? (bytes=? ptext plaintext))
           
           (printf "Plaintext  = ~a (~a Bytes)~n" (bytes->hex-string plaintext) (bytes-length plaintext))
           (printf "Cipher Key = ~a (~a Bits)~n" (bytes->hex-string key) (* (bytes-length key) 8))
           (fprintf (if encryption-okay? (current-output-port) (current-error-port))
                    "Ciphertext = ~a (~a Bytes)~n" (bytes->hex-string ctext) (bytes-length ctext))
           
           (when (not decryption-okay?)
             (eprintf "Plaintext  = ~a (~a Bytes)~n" (bytes->hex-string ptext) (bytes-length ptext)))

           (and encryption-okay? decryption-okay?)))

       (define aes-core-cipher!
         (lambda [0xplaintext 0xkey 0xciphertext]
           (define pool (symb0x->octets 0xplaintext))
           (define ciphertext (symb0x->octets 0xciphertext))
           (define key (symb0x->octets 0xkey))
           (define-values (encrypt! decrypt!) (aes-cipher! key))
           
           (encrypt! pool)
           
           (values (bytes->hex-string pool)
                   (bytes=? pool ciphertext))))
       
       (define HMAC
         (lambda [digest hmac-sha256 key message]
           (printf "Key  = ~a (~a Bytes)~n" (bytes->hex-string key) (bytes-length key))
           (printf "Data = ~a (~a Bytes)~n" (bytes->hex-string message) (bytes-length message))
           (printf "~s~n" digest)

           (bytes->hex-string ((hmac-sha256 key) message))))]
