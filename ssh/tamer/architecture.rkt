#lang scribble/lp2

@(require digimon/tamer)

@(define-bib SSH-ARCH
   #:title  "The Secure Shell Protocol Architecture"
   #:author (org-author-name "RFC4251")
   #:date   2006
   #:url    "https://tools.ietf.org/html/rfc4251")

@(define-bib OpenSSL
   #:title  "OpenSSL: Cryptography and SSL/TLS Toolkit"
   #:author (org-author-name "OpenSSL Software Foundation")
   #:date   2019
   #:url    "https://www.openssl.org")

@(define-bib HMAC-SHA
   #:title  "Identifiers and Test Vectors for HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512"
   #:author (org-author-name "RFC4231")
   #:date   2005
   #:url    "https://tools.ietf.org/html/rfc4231")

@(define-bib AES
   #:title  "Advanced Encryption Standard (AES) (FIPS PUB 197)"
   #:author (org-author-name "National Institute of Standards and Technology")
   #:date   2001
   #:url    "https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf")

@handbook-story{The Secure Shell Protocol Architecture}

This section demonstrates the implementation of @~cite[SSH-ARCH].

@;tamer-smart-summary[]

@handbook-scenario{Data Type Representation}

@tamer-action[
 (mpint '0x0)
 (mpint '0x9a378f9b2e332a7)
 (mpint '0x80)
 (mpint '0x-1234)
 (mpint '0x-deadbeef)]

@tamer-action[
 (namelist '())
 (namelist '(zlib))
 (namelist '(zlib none))]

@;handbook-scenario{Psuedo-Random Number Generation}

@handbook-scenario{Host Key Algorithms}

This testcase is generated by @~cite[OpenSSL].

@tamer-racketbox[(digimon-path "tamer" "stone" "openssl_rsa.pem")]

@tamer-action[
 (define pem (rsa-read openssl-rsa.pem))
 (rsa-key-okay? pem)
 (rsa-pretty-display pem 24)
 (define message (file->bytes (digimon-path "tamer" "stone" "openssl_rsa.pub")))
 (define signature (rsa-sign pem message id-sha1))
 (bytes=? signature (file->bytes (digimon-path "tamer" "stone" "openssl_rsa_sha1.sign")))
 (rsa-verify pem message signature id-sha1)]

@handbook-scenario{Confidentiality}

These test cases are defined in @~cite[AES].

@tamer-action[
 (aes-key-schedule aes-key128 4 #xb6630ca6)
 (aes-key-schedule aes-key192 6 #x01002202)
 (aes-key-schedule aes-key256 8 #x706c631e)]

@handbook-scenario{Data Integrity Algorithms}

These test cases are defined in @~cite[HMAC-SHA].

@tamer-action[
 (HMAC testcase1-256 hmac-sha256 (make-bytes 20 #x0B) #"Hi There")
 (HMAC testcase2-256 hmac-sha256 #"Jefe" #"what do ya want for nothing?")
 (HMAC testcase3-256 hmac-sha256 (make-bytes 20 #xAA) (make-bytes 50 #xDD))
 (HMAC testcase4-256 hmac-sha256 (apply bytes (range #x01 #x1A)) (make-bytes 50 #xCD))
 (HMAC testcase5-256 hmac-sha256-128 (make-bytes 20 #x0C) #"Test With Truncation")
 (HMAC testcase6-256 hmac-sha256 (make-bytes 131 #xAA) #"Test Using Larger Than Block-Size Key - Hash Key First")
 (HMAC testcase7-256 hmac-sha256 (make-bytes 131 #xAA) #"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.")]

@handbook-reference[]

@; Chunks after `handbook-reference[]` will never be rendered in documents
@; <*> is the main chunk by convention.

@chunk[|<*>|
       (require digimon/tamer)
       (tamer-taming-start!)

       (module+ tamer |<architecture:*>|)]

@chunk[|<architecture:*>|
       (module+ story
         <datatype>)]

@chunk[<datatype>
       (require "../datatype.rkt")
       (require "../digitama/rsa.rkt")
       (require "../digitama/algorithm/rsa.rkt")
       (require "../digitama/algorithm/hmac.rkt")
       
       (require "../digitama/algorithm/pkcs/hash.rkt")
       (require "../digitama/algorithm/pkcs/emsa-v1_5.rkt")
       (require "../digitama/algorithm/pkcs/primitive.rkt")

       (require "../digitama/algorithm/crypto/aes.rkt")
       (require "../digitama/algorithm/crypto/pretty.rkt")

       (define openssl-rsa.pem (digimon-path "tamer" "stone" "openssl_rsa.pem"))

       (define aes-key128 (bytes #x2b #x7e #x15 #x16 #x28 #xae #xd2 #xa6 #xab #xf7 #x15 #x88 #x09 #xcf #x4f #x3c))
       (define aes-key192 (bytes #x8e #x73 #xb0 #xf7 #xda #x0e #x64 #x52 #xc8 #x10 #xf3 #x2b
                                 #x80 #x90 #x79 #xe5 #x62 #xf8 #xea #xd2 #x52 #x2c #x6b #x7b))
       (define aes-key256 (bytes #x60 #x3d #xeb #x10 #x15 #xca #x71 #xbe #x2b #x73 #xae #xf0 #x85 #x7d #x77 #x81
                                 #x1f #x35 #x2c #x07 #x3b #x61 #x08 #xd7 #x2d #x98 #x10 #xa3 #x09 #x14 #xdf #xf4))
       
       (define testcase1-256 "b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7")
       (define testcase2-256 "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843")
       (define testcase3-256 "773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe")
       (define testcase4-256 "82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b")
       (define testcase5-256 "a3b6167473100ee06e0c796c2955552b")
       (define testcase6-256 "60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54")
       (define testcase7-256 "9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2")
       
       (define octets->integer
         (lambda [os]
           (pkcs#1-octets->integer (apply bytes (map symb0x->number (flatten os))))))
       
       (define mpint
         (lambda [hex]
           (define raw (~a hex))
           (define mphex (string->number (substring raw 2) 16))
           (define bs (ssh-mpint->bytes mphex))
           (define-values (restored _) (ssh-bytes->mpint bs))
           (cons (number->symb0x restored) (bytes->hex-string bs #:separator " "))))

       (define namelist
         (lambda [names]
           (define bs (ssh-namelist->bytes names))
           (define-values (restored _) (ssh-bytes->namelist bs))
           (cons restored (bytes->hex-string bs #:separator " "))))

       (define aes-key-schedule
         (lambda [key column last-one]
           (printf "Cipher Key = ~a (~a bits)~n" (bytes->hex-string key) (* (bytes-length key) 8))
           (printf "Last Word  = ~a~n" (number->string last-one 16))

           (define schedule (aes-key-expand key 16))
           (define last-word (integer-bytes->integer schedule #false #true (- (bytes-length schedule) 4)))

           (words-pretty-print schedule #:column column #:port (if (= last-word last-one) (current-output-port) (current-error-port)))))
       
       (define HMAC
         (lambda [digest hmac-sha256 key message]
           (printf "Key  = ~a (~a Bytes)~n" (bytes->hex-string key) (bytes-length key))
           (printf "Data = ~a (~a Bytes)~n" (bytes->hex-string message) (bytes-length message))
           (printf "~s~n" digest)

           (bytes->hex-string ((hmac-sha256 key) message))))]
