#lang scribble/lp2

@(require digimon/tamer)

@(define-bib SSH-ARCH
   #:title    "The Secure Shell Protocol Architecture"
   #:author   (org-author-name "RFC4251")
   #:date     2006
   #:url      "https://tools.ietf.org/html/rfc4251")

@(define-bib OpenSSL
   #:title    "OpenSSL: Cryptography and SSL/TLS Toolkit"
   #:author   (org-author-name "OpenSSL Software Foundation")
   #:date     2019
   #:url      "https://www.openssl.org")

@(define-bib HMAC-SHA
   #:title    "Identifiers and Test Vectors for HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512"
   #:author   (org-author-name "RFC4231")
   #:date     2005
   #:url      "https://tools.ietf.org/html/rfc4231")

@handbook-story{The Secure Shell Protocol Architecture}

This section demonstrates the implementation of @~cite[SSH-ARCH].

@;tamer-smart-summary[]

@handbook-scenario{Data Type Representation}

@tamer-action[
 (mpint '0x0)
 (mpint '0x9a378f9b2e332a7)
 (mpint '0x80)
 (mpint '0x-1234)
 (mpint '0x-deadbeef)]

@tamer-action[
 (namelist '())
 (namelist '(zlib))
 (namelist '(zlib none))]

@handbook-scenario{Host Key Algorithms}

This testcase is generated by @~cite[OpenSSL].

@tamer-racketbox[(digimon-path "stone" "openssl_rsa.pem")]

@tamer-action[
 (code:comment "openssl genrsa 2048")
 (define-values (pem rsa?) (pem-read (digimon-path "stone" "openssl_rsa.pem") #:label 'RSA-Private-Key))
 (unless (not rsa?) (rsa-key (unsafe-bytes->rsa-private-key* pem)))]

@handbook-scenario{Data Integrity Algorithms}

These test cases are defined in @~cite[HMAC-SHA].

@tamer-action[
 (hmac-sha256 (make-bytes 20 #x0B) #"Hi There")
 (hmac-sha256 #"Jefe" #"what do ya want for nothing?")
 (hmac-sha256 (make-bytes 20 #xAA) (make-bytes 50 #xDD))
 (hmac-sha256 (apply bytes (range #x01 #x1A)) (make-bytes 50 #xCD))
 (hmac-sha256-128 (make-bytes 20 #x0C) #"Test With Truncation")
 (hmac-sha256 (make-bytes 131 #xAA) #"Test Using Larger Than Block-Size Key - Hash Key First")
 (hmac-sha256 (make-bytes 131 #xAA) #"This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.")]

@handbook-reference[]

@; Chunks after `handbook-reference[]` will never be rendered in documents
@; <*> is the main chunk by convention.

@chunk[|<*>|
       (require digimon/tamer)
       (tamer-taming-start!)

       (module+ tamer |<architecture:*>|)]

@chunk[|<architecture:*>|
       (module+ story
         <datatype>)]

@chunk[<datatype>
       (require "../datatype.rkt")
       (require "../digitama/algorithm/hmac.rkt")
       (require "../digitama/algorithm/rsa.rkt")
       
       (require "../digitama/algorithm/pkcs/primitive.rkt")
       (require "../digitama/algorithm/pkcs/key.rkt")

       (require "../digitama/asn-der/pretty.rkt")
       (require "../digitama/pem.rkt")

       (define octets->integer
         (lambda [os]
           (pkcs#1-octets->integer (apply bytes (map symb0x->number (flatten os))))))
       
       (define mpint
         (lambda [hex]
           (define raw (~a hex))
           (define mphex (string->number (substring raw 2) 16))
           (define bs (ssh-mpint->bytes mphex))
           (define-values (restored _) (ssh-bytes->mpint bs))
           (cons (number->symb0x restored) (bytes->hex-string bs #:separator " "))))

       (define namelist
         (lambda [names]
           (define bs (ssh-namelist->bytes names))
           (define-values (restored _) (ssh-bytes->namelist bs))
           (cons restored (bytes->hex-string bs #:separator " "))))

       (define rsa-key
         (lambda [pem]
           (define k (rsa-keygen (list (rsa-private-key-p pem) (rsa-private-key-q pem)) #:e (rsa-private-key-e pem)))
           (printf "e    = ~a~n" (rsa-private-key-e pem))
           ((if (eqv? (rsa-private-key-n pem) (rsa-private-key-n k)) printf eprintf) "n    = ~a~n" (rsa-private-key-n pem))
           ((if (eqv? (rsa-private-key-d pem) (rsa-private-key-d k)) printf eprintf) "d    = ~a~n" (rsa-private-key-d pem))
           ((if (eqv? (rsa-private-key-dP pem) (rsa-private-key-dP k)) printf eprintf) "dP   = ~a~n" (rsa-private-key-dP pem))
           ((if (eqv? (rsa-private-key-dQ pem) (rsa-private-key-dQ k)) printf eprintf) "dQ   = ~a~n" (rsa-private-key-dQ pem))
           ((if (eqv? (rsa-private-key-qInv pem) (rsa-private-key-qInv k)) printf eprintf) "qInv = ~a~n" (rsa-private-key-qInv pem))
           k))

       (define hmac-sha256
         (lambda [key message]
           (printf "Key  = ~a (~a Bytes)~n" (bytes->hex-string key) (bytes-length key))
           (printf "Data = ~a (~a Bytes)~n" (bytes->hex-string message) (bytes-length message))
           (bytes->hex-string (ssh-hmac-sha256 key message))))

       (define hmac-sha256-128
         (lambda [key message]
           (printf "Key  = ~a (~a Bytes)~n" (bytes->hex-string key) (bytes-length key))
           (printf "Data = ~a (~a Bytes)~n" (bytes->hex-string message) (bytes-length message))
           (bytes->hex-string (ssh-hmac-sha256-128 key message))))]
